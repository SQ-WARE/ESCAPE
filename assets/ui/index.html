<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="{{CDN_ASSETS_URL}}/ui/css/app.css">
</head>
<body>
  <div id="sprint-warning" class="sprint-warning" hidden></div>
  <div id="healing-effect" class="healing-effect"></div>
  <div id="movement-speed-indicator" class="movement-speed-indicator" hidden>
    <div class="speed-icon">ðŸš¶</div>
    <div class="speed-text">Movement Slowed</div>
  </div>
  <div class="crosshair">
    <div class="crosshair-dot"></div>
    <div class="crosshair-line crosshair-line-top"></div>
    <div class="crosshair-line crosshair-line-bottom"></div>
    <div class="crosshair-line crosshair-line-left"></div>
    <div class="crosshair-line crosshair-line-right"></div>
  </div>
  <div class="scope-overlay">
    <div class="scope-reticle"></div>
  </div>
  <div class="reload-prompt" hidden>
    <span class="reload-text">Press R to reload</span>
  </div>
  <div class="reload-text-container" hidden>
    <span class="reload-text">RELOADING...</span>
  </div>
  <div class="medkit-progress-container" hidden>
    <div class="medkit-progress-bar">
      <div class="medkit-progress-fill"></div>
    </div>
    <span class="medkit-text">Using Medkit...</span>
  </div>
  <div class="damage-flash"></div>
  <div class="health-container">
    <div class="health-bar"></div>
    <span class="health-text">100</span>
  </div>
  <div class="weapon-container" hidden>
    <div class="weapon-info">
      <img class="weapon-icon" src="" alt="">
      <div class="weapon-details">
        <span class="weapon-name">No Weapon</span>
        <span class="weapon-description"></span>
      </div>
    </div>
    <div class="ammo-counter">
      <span class="ammo-text">0/0</span>
    </div>
  </div>
  <div id="extraction-container" class="extraction-container" hidden>
    <div class="extraction-panel ui-panel">
      <div class="extraction-title">Extraction</div>
      <div class="extraction-zone">ZONE: <span id="extraction-zone-name">N/A</span></div>
      <div class="extraction-progress-bar">
        <div class="extraction-progress-fill"></div>
      </div>
      <div class="extraction-remaining"><span id="extraction-remaining">20</span>s remaining</div>
    </div>
  </div>
  <div id="message-container" class="message-container"></div>
  <div id="compass-indicator" style="position:fixed; top:12px; right:12px; font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; font-weight:700; font-size:18px; color:#ffffff; text-shadow:0 0 6px rgba(0,0,0,0.7); letter-spacing:1px; opacity:0.85; z-index:9999; pointer-events:none;">N</div>
  <div id="raid-timer" class="raid-timer ui-panel" style="position:fixed; top:12px; right:76px; z-index:1000; display:none; padding:6px 10px; font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; font-weight:800; letter-spacing:0.5px;">
    <span id="raid-session-label">ALPHA</span>
    <span> â€¢ </span>
    <span id="raid-time-left">--:--</span>
    <span> â€¢ </span>
    <span id="raid-world-time">00:00</span>
  </div>
  <div class="tactical-hotbar">
    <div class="hotbar-grid"></div>
  </div>
  <div class="inventory-overlay" hidden>
    <div class="tactical-inventory glass-elevated animate-fade-in-scale">
      <div class="inventory-header">
        <span class="inventory-title">TACTICAL BACKPACK</span>
        <button class="close-btn">Ã—</button>
      </div>
      <div class="inventory-grid-container glass-surface glass-border-strong">
        <div class="backpack-grid" data-container="backpack"></div>
      </div>
      <div class="hotbar-section">
        <span class="hotbar-label">QUICK ACCESS</span>
        <div class="inventory-hotbar-grid" data-container="hotbar"></div>
      </div>
      <div class="drag-instructions">
        <span class="drag-text">Drag items to move â€¢ Press Q to drop â€¢ ESC to close</span>
      </div>
          <div class="drag-ghost"></div>
  </div>
</div>

<div class="kill-feed">
  <div class="kill-feed-container">
    <!-- Kill feed entries will be dynamically added here -->
  </div>
</div>

  <div id="screen-fader" class="screen-fader hidden"></div>

  <template id="item-nameplate">
    <div class="item-nameplate-container">
      <div class="item-nameplate ui-panel glass-elevated">
        <div class="item-nameplate-icon"><img class="item-icon-image" src="" alt=""></div>
        <div class="item-nameplate-name">Item</div>
        <div class="item-nameplate-quantity" hidden></div>
      </div>
      <div class="item-nameplate-interact">
        <div class="interact-text">Press F to interact</div>
      </div>
    </div>
  </template>

<script>
  const CDN_ASSETS_URL = '{{CDN_ASSETS_URL}}';
  const HOTBAR_SLOTS = 9;
  const BACKPACK_SLOTS = 27;

  const healthBar = document.querySelector('.health-bar');
  const healthText = document.querySelector('.health-text');
  const damageFlash = document.querySelector('.damage-flash');
  const ammoText = document.querySelector('.ammo-text');
  const weaponName = document.querySelector('.weapon-name');
  const weaponIcon = document.querySelector('.weapon-icon');
  const weaponContainer = document.querySelector('.weapon-container');
  const weaponDescriptionEl = document.querySelector('.weapon-description');
  const hotbarGrid = document.querySelector('.hotbar-grid');
  const reloadPrompt = document.querySelector('.reload-prompt');
  const reloadTextContainer = document.querySelector('.reload-text-container');
  const medkitProgressContainer = document.querySelector('.medkit-progress-container');
  const medkitProgressFill = document.querySelector('.medkit-progress-fill');
  const inventoryOverlay = document.querySelector('.inventory-overlay');
  const backpackGrid = document.querySelector('[data-container="backpack"]');
  const inventoryHotbarGrid = document.querySelector('[data-container="hotbar"]');
  const dragGhost = document.querySelector('.drag-ghost');
  const closeBtn = document.querySelector('.close-btn');
  const crosshairEl = document.querySelector('.crosshair');
  const crosshairLinesEls = document.querySelectorAll('.crosshair-line');
  const scopeOverlayEl = document.querySelector('.scope-overlay');
  const healingEffectEl = document.getElementById('healing-effect');
  const medkitTextEl = document.querySelector('.medkit-text');
  const movementSpeedIndicatorEl = document.getElementById('movement-speed-indicator');
  const sprintWarningEl = document.getElementById('sprint-warning');
  const extractionContainerEl = document.getElementById('extraction-container');
  const extractionZoneNameEl = document.getElementById('extraction-zone-name');
  const extractionProgressFillEl = document.querySelector('.extraction-progress-fill');
  const extractionRemainingEl = document.getElementById('extraction-remaining');
  hytopia.registerSceneUITemplate('item-nameplate', (id, onState) => {
    const tpl = document.getElementById('item-nameplate');
    const root = tpl.content.cloneNode(true);
    const nameEl = root.querySelector('.item-nameplate-name');
    const qtyEl = root.querySelector('.item-nameplate-quantity');
    const iconEl = root.querySelector('.item-icon-image');
    const interactText = root.querySelector('.interact-text');
    onState(state => {
      if (state && typeof state.name === 'string') {
        nameEl.textContent = state.name;
      }
      if (state && typeof state.iconImageUri === 'string') {
        iconEl.src = `${CDN_ASSETS_URL}/${state.iconImageUri}`;
      }
      if (state && typeof state.quantity === 'number') {
        if (state.quantity > 1) {
          qtyEl.style.display = 'inline-block';
          qtyEl.textContent = `x${state.quantity}`;
        } else {
          qtyEl.style.display = 'none';
        }
      }
      if (state && state.showPickupArea === true) {
        interactText.textContent = 'Press F to pick up';
      }
      if (state && state.rarityColor) {
        const { r, g, b } = state.rarityColor;
        nameEl.style.color = `rgb(${r}, ${g}, ${b})`;
      }
    });
    return root;
  });

  let dragState = null;
  let hoveredSlot = null;
  let isInventoryOpen = false;
  let dropHoverSlot = null;

  const openInventory = () => {
    inventoryOverlay.style.display = 'flex';
    isInventoryOpen = true;
    hytopia.lockPointer(false, true);
    if (backpackGrid.children.length === 0) {
      initializeInventoryGrids();
    }
    hytopia.sendData({ type: 'inventoryOpened' });
  };

  const closeInventory = () => {
    inventoryOverlay.style.display = 'none';
    isInventoryOpen = false;
    hytopia.lockPointer(true);
    if (dragState) {
      cancelDragOperation();
    }
    hytopia.sendData({ type: 'inventoryClosed' });
  };

  const cancelDragOperation = () => {
    if (dragState) {
      document.querySelectorAll('.slot').forEach(slot => {
        slot.classList.remove('drag-source', 'drop-target');
      });
      dragGhost.classList.remove('active');
      dragGhost.innerHTML = '';
      removeEmptySlotHighlighting();
      dragState = null;
    }
  };

  document.addEventListener('keydown', (e) => {
    if (isInventoryOpen) {
      handleInventoryKeydown(e);
    } else {
      handleGameplayKeydown(e);
    }
  });

  const handleInventoryKeydown = e => {
    if (e.key === 'Escape') {
      closeInventory();
      return;
    }
    
    if (e.key === 'q' || e.key === 'Q') {
      if (hoveredSlot && hoveredSlot.querySelector('img')) {
        const container = hoveredSlot.parentElement.dataset.container;
        const index = Array.from(hoveredSlot.parentElement.children).indexOf(hoveredSlot);
        hytopia.sendData({ type: 'dropItem', fromType: container, fromIndex: index });
      }
      return;
    }
    
    const key = parseInt(e.key, 10);
    if (key >= 1 && key <= HOTBAR_SLOTS) {
      if (!hoveredSlot) return;
      const container = hoveredSlot.parentElement?.dataset?.container;
      const fromIndex = Array.from(hoveredSlot.parentElement.children).indexOf(hoveredSlot);
      const numberIndex = key - 1;

      if (hoveredSlot.querySelector('img')) {
        // Assign hovered item to numbered hotbar slot
        const targetHotbarSlot = hotbarGrid.children[numberIndex];
        if (targetHotbarSlot) {
          targetHotbarSlot.classList.add('assigning');
          setTimeout(() => targetHotbarSlot.classList.remove('assigning'), 300);
        }
        hytopia.sendData({
          type: 'moveItem',
          fromType: container,
          fromIndex: fromIndex,
          toType: 'hotbar',
          toIndex: numberIndex
        });
      } else if (container === 'backpack') {
        // Move hotbar item at numberIndex into hovered empty backpack slot
        const toIndex = fromIndex;
        hytopia.sendData({
          type: 'moveItem',
          fromType: 'hotbar',
          fromIndex: numberIndex,
          toType: 'backpack',
          toIndex
        });
      }
    }
  };

  const handleGameplayKeydown = e => {
    if (e.key === 'Q' || e.key === 'q') {
      const activeSlot = document.querySelector('.hotbar-slot.active');
      if (activeSlot && activeSlot.querySelector('img')) {
        const index = Array.from(activeSlot.parentElement.children).indexOf(activeSlot);
        hytopia.sendData({ type: 'dropItem', fromType: 'hotbar', fromIndex: index });
      }
    }
    
    const key = parseInt(e.key, 10);
    if (key >= 1 && key <= HOTBAR_SLOTS) {
      hytopia.sendData({ type: 'setSelectedHotbarIndex', index: key - 1 });
    }
  }

  closeBtn.addEventListener('click', closeInventory);
  

  document.addEventListener('contextmenu', (e) => {
    if (dragState && dragState.isDragging) {
      e.preventDefault();
    }
  });

  hytopia.onData(data => {
    switch (data.type) {
      case 'prewarmHud':
        // Pre-warm core HUD widgets to avoid style flash on load
        updateHealth({ health: 100, maxHealth: 100 });
        setActiveSlot(0);
        break;
      case 'health':
        updateHealth(data);
        break;
      case 'damage':
        showDamageFlash();
        break;
      case 'ammo':
        updateAmmoDisplay(data);
        break;
      case 'reload':
        ammoText.textContent = 'RELOADING';
        reloadPrompt.style.display = 'none';
        reloadTextContainer.style.display = 'none';
        break;
      case 'ammo-indicator':
        updateAmmoIndicator(data);
        break;
      case 'weapon':
        updateWeaponDisplay(data);
        break;
      case 'hotbarUpdate':
        updateHotbarSlot(data.position, data);
        updateInventorySlot(inventoryHotbarGrid, data.position, data);
        removeEmptySlotHighlighting();
        break;
      case 'setSelectedHotbarIndex':
        setActiveSlot(data.index);
        break;
      case 'reload-prompt':
        reloadPrompt.style.display = data.show ? 'block' : 'none';
        break;
      case 'reload-error':
      case 'reload-success':
      case 'weapon-message':
      case 'shoot-error':
        showMessage(data.message, getMessageType(data.type));
        break;
      case 'sprint-warning':
        updateSprintWarning(data);
        break;
      case 'reload-progress':
        updateReloadProgress(data);
        break;
      case 'medkit-use':
        updateMedkitProgress(data);
        break;
      case 'healing-complete':
        showHealingComplete(data);
        break;
      case 'healing-bonus-activated':
        showHealingBonusActivated(data);
        break;
      case 'healing-bonus-ended':
        showHealingBonusEnded();
        break;
      case 'notification':
        showMessage(data.message, getNotificationType(data.color));
        break;
      case 'crosshair-state':
        updateCrosshairState(data);
        break;
      case 'scope-zoom':
        updateScopeZoom(data);
        break;
      case 'recoil':
        updateRecoil(data);
        break;
      case 'extraction-start':
        showExtraction(data);
        break;
      case 'extraction-progress':
        updateExtraction(data);
        break;
      case 'extraction-cancel':
        hideExtraction();
        break;
      case 'hitmarker':
        showHitmarker(data);
        break;
      case 'backpackUpdate':
        updateInventorySlot(backpackGrid, data.position, data);
        removeEmptySlotHighlighting();
        break;

      case 'showInventory':
        openInventory();
        break;
      case 'hideInventory':
        closeInventory();
        break;
      case 'screen-fade':
        setScreenFade(data.show === true, data.durationMs);
        break;
      case 'compass':
        updateCompass(data);
        break;
      case 'raid-timer':
        updateRaidTimer(data);
        break;
              case 'kill-feed':
          addKillFeedEntry(data.killerName, data.weaponIconUri, data.victimName);
          break;
    }
  });

  const updateHealth = data => {
    const percentage = (data.health / data.maxHealth) * 100;
    healthBar.style.width = `${percentage}%`;
    healthText.textContent = Math.ceil(data.health);
  };

  const showDamageFlash = () => {
    damageFlash.classList.add('active');
    setTimeout(() => damageFlash.classList.remove('active'), 200);
  };

  const updateAmmoDisplay = data => {
    ammoText.textContent = `${data.ammo}/${data.maxAmmo}`;
    reloadPrompt.style.display = (data.ammo === 0 && data.maxAmmo > 0) ? 'block' : 'none';
  };

  const updateAmmoIndicator = data => {
    if (data.show === false) {
      weaponContainer.style.display = 'none';
      reloadPrompt.style.display = 'none';
    } else {
      weaponContainer.style.display = 'block';
      if (data.reloading) {
        ammoText.textContent = 'RELOADING';
        reloadPrompt.style.display = 'none';
        reloadTextContainer.style.display = 'none';
      } else {
        updateAmmoDisplay(data);
      }
    }
  };

  const updateWeaponDisplay = data => {
    weaponName.textContent = data.name.toUpperCase();
    weaponIcon.src = `${CDN_ASSETS_URL}/${data.iconImageUri}`;
    
    if (weaponDescriptionEl && data.description) {
      const lines = data.description.split('\n');
      const descLines = [];
      for (const line of lines) {
        if (line.trim() === '' || line.includes('Ammo:') || line.includes('Damage:') || 
            line.includes('Fire Rate:') || line.includes('Range:') || line.includes('Magazine:')) {
          break;
        }
        descLines.push(line.trim());
      }
      weaponDescriptionEl.textContent = descLines.join(' ').trim() || '';
    }
  };

  const updateSprintWarning = data => {
    sprintWarningEl.textContent = data.message;
    sprintWarningEl.style.display = data.show ? 'block' : 'none';
  };

  const updateReloadProgress = data => {
    reloadTextContainer.style.display = data.show === false ? 'none' : 'block';
    // Ensure reload prompt is hidden when reload progress is shown
    if (data.show !== false) {
      reloadPrompt.style.display = 'none';
    }
  };

  const updateMedkitProgress = data => {
    const isUsing = data.isUsing === true;
    medkitProgressContainer.style.display = isUsing ? 'block' : 'none';
    medkitProgressFill.style.width = isUsing ? `${Math.max(0, Math.min(100, data.progress || 0))}%` : '0%';
    healingEffectEl.classList.toggle('active', isUsing);
    movementSpeedIndicatorEl.hidden = !isUsing;
    medkitTextEl.textContent = isUsing ? 'HEALING - MOVEMENT SLOWED' : 'HEALING';
  };

  const updateCrosshairState = data => {
    crosshairEl.classList.toggle('can-fire', data.canFire);
    crosshairEl.classList.toggle('cannot-fire', !data.canFire);
  };

  const updateScopeZoom = data => {
    scopeOverlayEl.classList.toggle('active', data.zoom !== 1);
  };

  const updateRecoil = data => {
    const expansionRatio = data.recoil / data.maxRecoil;
    const expansion = 8 + (expansionRatio * 80);
    
    crosshairEl.classList.toggle('recoiling', data.recoil > 0.01);
    
    crosshairLinesEls.forEach(line => {
      const isTop = line.classList.contains('crosshair-line-top');
      const isBottom = line.classList.contains('crosshair-line-bottom');
      const isLeft = line.classList.contains('crosshair-line-left');
      const isRight = line.classList.contains('crosshair-line-right');
      
      if (isTop) line.style.transform = `translate(-50%, calc(-50% - ${expansion}px))`;
      else if (isBottom) line.style.transform = `translate(-50%, calc(-50% + ${expansion}px))`;
      else if (isLeft) line.style.transform = `translate(calc(-50% - ${expansion}px), -50%)`;
      else if (isRight) line.style.transform = `translate(calc(-50% + ${expansion}px), -50%)`;
    });
    crosshairEl.style.transform = `translate(-50%, -50%)`;
  };

  const showHitmarker = data => {
    if (data.hit) {
      const className = data.kill ? 'hitmarker-kill' : 'hitmarker-hit';
      const duration = data.kill ? 300 : 200;
      crosshairEl.classList.add(className);
      setTimeout(() => crosshairEl.classList.remove(className), duration);
    }
  };

  const showExtraction = data => {
    extractionContainerEl.style.display = 'block';
    extractionZoneNameEl.textContent = data.zoneName || 'EXFIL';
    extractionProgressFillEl.style.width = '0%';
    extractionRemainingEl.textContent = data.holdSeconds ?? 20;
  };

  const updateExtraction = data => {
    if (data.zoneName) extractionZoneNameEl.textContent = data.zoneName;
    if (typeof data.progress === 'number') {
      extractionProgressFillEl.style.width = `${Math.max(0, Math.min(100, data.progress))}%`;
    }
    if (typeof data.remainingSeconds === 'number') {
      extractionRemainingEl.textContent = data.remainingSeconds;
    }
  };

  const hideExtraction = () => extractionContainerEl.style.display = 'none';

  const updateRaidTimer = data => {
    const el = document.getElementById('raid-timer');
    const lbl = document.getElementById('raid-session-label');
    const timeEl = document.getElementById('raid-time-left');
    const worldTimeEl = document.getElementById('raid-world-time');
    if (!el || !lbl || !timeEl) return;
    
    const left = Math.max(0, parseInt(data.secondsLeft || 0));
    const m = Math.floor(left / 60);
    const s = left % 60;
    timeEl.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    lbl.textContent = String(data.sessionId || '').toUpperCase();
    if (worldTimeEl) worldTimeEl.textContent = data.worldTimeFormatted || '12:00 AM';
    
    el.style.display = 'inline-block';
    
    if (left <= 10) {
      el.style.borderColor = 'rgba(255,0,0,0.8)';
      el.style.boxShadow = '0 0 20px rgba(255,0,0,0.6)';
      el.style.animation = 'pulse-critical 0.5s ease-in-out infinite alternate';
    } else if (left <= 30) {
      el.style.borderColor = 'rgba(255,0,0,0.7)';
      el.style.boxShadow = '0 0 15px rgba(255,0,0,0.5)';
      el.style.animation = 'pulse-urgent 1s ease-in-out infinite alternate';
    } else if (left <= 60) {
      el.style.borderColor = 'rgba(255,100,0,0.6)';
      el.style.boxShadow = '0 0 12px rgba(255,100,0,0.4)';
      el.style.animation = '';
    } else if (left <= 120) {
      el.style.borderColor = 'rgba(255,160,0,0.5)';
      el.style.boxShadow = '0 0 12px rgba(255,160,0,0.35)';
      el.style.animation = '';
    } else {
      el.style.borderColor = '';
      el.style.boxShadow = '';
      el.style.animation = '';
    }
  };



  const getMessageType = type => ({
    'reload-error': 'error',
    'shoot-error': 'error',
    'reload-success': 'success',
    'weapon-message': 'warning'
  }[type] || 'info');

  const getNotificationType = color => color === 'FF0000' ? 'error' : color === '00FF00' ? 'success' : 'info';

  const showHealingComplete = () => {
    healingEffectEl.classList.remove('active');
    movementSpeedIndicatorEl.hidden = true;
  };

  const showHealingBonusActivated = data => {
    const bonusIndicator = document.createElement('div');
    bonusIndicator.className = 'healing-bonus-indicator';
    bonusIndicator.innerHTML = `
      <div class="bonus-icon">ðŸ’š</div>
      <div class="bonus-text">Enhanced Regeneration Active</div>
      <div class="bonus-timer">${Math.ceil(data.duration / 1000)}s</div>
    `;
    bonusIndicator.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 255, 0, 0.2);
      backdrop-filter: blur(16px);
      border: 2px solid rgba(0, 255, 0, 0.4);
      border-radius: 12px;
      padding: 12px 16px;
      color: #00ff44;
      font-family: 'Inter', sans-serif;
      font-weight: 600;
      z-index: 1000;
      animation: healingBonusSlideIn 0.5s ease-out;
    `;
    
    document.body.appendChild(bonusIndicator);
    
    setTimeout(() => {
      if (bonusIndicator.parentNode) {
        bonusIndicator.style.animation = 'healingBonusSlideOut 0.5s ease-out';
        setTimeout(() => {
          if (bonusIndicator.parentNode) {
            bonusIndicator.parentNode.removeChild(bonusIndicator);
          }
        }, 500);
      }
    }, data.duration);

    showMessage(`ðŸ’š Enhanced regeneration activated! (${data.multiplier}x healing)`, 'success');
  };

  const showHealingBonusEnded = () => showMessage('Enhanced regeneration ended', 'info');

  const showMessage = (message, type = 'info') => {
    const messageContainer = document.getElementById('message-container');
    if (!messageContainer) return;
    
    const messageElement = document.createElement('div');
    messageElement.className = `message ui-panel message-${type}`;
    messageElement.textContent = message;
    messageContainer.appendChild(messageElement);
    setTimeout(() => {
      if (messageElement.parentNode) {
        messageElement.parentNode.removeChild(messageElement);
      }
    }, 3000);
  };

  const updateHotbarSlot = (position, itemData) => {
    const slot = hotbarGrid.children[position];
    if (!slot) return;
    
    // Remove all rarity classes first
    slot.classList.remove('rarity-common', 'rarity-unusual', 'rarity-rare', 'rarity-epic', 'rarity-legendary', 'rarity-utopian');
    
    if (itemData.removed) {
      slot.innerHTML = `<span class="slot-number">${position + 1}</span>`;
    } else {
      const isAmmo = itemData.name && (
        itemData.name.includes('9Ã—19mm') || 
        itemData.name.includes('7.62Ã—39mm') || 
        itemData.name.includes('12.7Ã—108mm')
      );
      const quantityDisplay = isAmmo && itemData.quantity > 1 ? 
        `<span class="ammo-label">${itemData.quantity}</span>` :
        itemData.quantity > 1 ? `<span class="item-quantity">${itemData.quantity}</span>` : '';
      
      slot.innerHTML = `
        <span class="slot-number">${position + 1}</span>
        <img src="${CDN_ASSETS_URL}/${itemData.iconImageUri}" title="${itemData.name}">
        ${quantityDisplay}
      `;
      
      // Add rarity class for stained glass effect
      const rarity = itemData.rarity || 'common';
      slot.classList.add(`rarity-${rarity}`);
    }
  };

  const updateInventorySlot = (grid, position, itemData) => {
    const slot = grid.children[position];
    if (!slot) return;
    
    // Remove all rarity classes first
    slot.classList.remove('rarity-common', 'rarity-unusual', 'rarity-rare', 'rarity-epic', 'rarity-legendary', 'rarity-utopian');
    
    removeTooltip(slot);
    
    if (!dragState || !dragState.isDragging) {
      slot.classList.remove('drag-source', 'drop-target');
    } else {
      slot.classList.remove('drag-source');
    }
    
    if (itemData.removed) {
      slot.innerHTML = '';
      slot._itemData = null;
      if (dragState && dragState.isDragging && !slot.querySelector('img')) {
        slot.classList.add('drop-target');
      }
    } else {
      if (dragState && dragState.isDragging) {
        slot.classList.remove('drop-target');
      }
      const quantityDisplay = itemData.quantity > 1 ? `<span class="item-quantity">${itemData.quantity}</span>` : '';
      slot.innerHTML = `
        <img src="${CDN_ASSETS_URL}/${itemData.iconImageUri}" alt="${itemData.name}">
        ${quantityDisplay}
      `;
      slot._itemData = itemData;
      slot._tooltipEnabled = true;
      
      // Add rarity class for stained glass effect
      const rarity = itemData.rarity || 'common';
      slot.classList.add(`rarity-${rarity}`);
      
      slot.removeEventListener('mouseenter', createLazyTooltip);
      slot.addEventListener('mouseenter', createLazyTooltip);
    }
    
    if (grid === inventoryHotbarGrid && itemData.selected !== undefined) {
      slot.classList.toggle('active', itemData.selected);
    }
  };

  const setActiveSlot = index => {
    document.querySelectorAll('.hotbar-slot').forEach((slot, i) => {
      slot.classList.toggle('active', i === index);
    });
    if (isInventoryOpen) {
      document.querySelectorAll('.inventory-hotbar-grid .slot').forEach((slot, i) => {
        slot.classList.toggle('active', i === index);
      });
    }
  };

  const initializeHotbar = () => {
    for (let i = 0; i < HOTBAR_SLOTS; i++) {
      const slot = document.createElement('div');
      slot.className = 'hotbar-slot';
      slot.innerHTML = `<span class="slot-number">${i + 1}</span>`;
      if (i === 0) slot.classList.add('active');
      slot.addEventListener('click', () => {
        hytopia.sendData({ type: 'setSelectedHotbarIndex', index: i });
      });
      hotbarGrid.appendChild(slot);
    }
  };

  const initializeInventoryGrids = () => {
    for (let i = 0; i < BACKPACK_SLOTS; i++) {
      backpackGrid.appendChild(createInventorySlot());
    }
    for (let i = 0; i < HOTBAR_SLOTS; i++) {
      const slot = createInventorySlot();
      if (i === 0) slot.classList.add('active');
      slot.addEventListener('click', () => {
        hytopia.sendData({ type: 'setSelectedHotbarIndex', index: i });
      });
      inventoryHotbarGrid.appendChild(slot);
    }
  };

  const createInventorySlot = () => {
    const slot = document.createElement('div');
    slot.className = 'slot';
    slot.addEventListener('mouseenter', () => hoveredSlot = slot);
    slot.addEventListener('mouseleave', () => { 
      hoveredSlot = null;
      if (slot._tooltip) slot._tooltip.style.display = 'none';
    });
    slot.addEventListener('mousedown', handleMouseDown);
    return slot;
  };

  const handleMouseDown = e => {
    const slot = e.currentTarget;
    const img = slot.querySelector('img');
    if (!img || e.button !== 0) return;
    e.preventDefault();

    if (e.shiftKey) {
      const container = slot.parentElement.dataset.container;
      const index = Array.from(slot.parentElement.children).indexOf(slot);
      hytopia.sendData({ type: 'quickMoveItem', fromType: container, fromIndex: index });
      return;
    }
    
    removeTooltip(slot);
    
    const container = slot.parentElement.dataset.container;
    const index = Array.from(slot.parentElement.children).indexOf(slot);
    dragState = {
      slot,
      container,
      index,
      startX: e.clientX,
      startY: e.clientY,
      isDragging: false
    };
    document.addEventListener('mousemove', handleMouseMove, { capture: true });
    document.addEventListener('mouseup', handleMouseUp);
  };

  const handleMouseMove = e => {
    if (!dragState) return;
    const dx = e.clientX - dragState.startX;
    const dy = e.clientY - dragState.startY;
    if (!dragState.isDragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
      startDrag(e);
    }
    if (dragState.isDragging) {
      dragGhost.style.left = `${e.clientX + 15}px`;
      dragGhost.style.top = `${e.clientY - 15}px`;
      dragGhost.style.transform = 'translate(-50%, -50%)';
      updateDropHover(e);
    }
  };

  const handleMouseUp = e => {
    if (dragState && dragState.isDragging) {
      handleDragEnd(e);
    }
    document.querySelectorAll('.slot').forEach(slot => {
      slot.classList.remove('drag-source', 'drop-target', 'drop-hover');
    });
    
    setEmptySlotHighlighting(false);
    
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
    dragState = null;
    
    setTimeout(() => {
      document.querySelectorAll('.slot').forEach(slot => {
        if (slot._itemData) slot._tooltipEnabled = true;
      });
    }, 100);
  };

  const startDrag = e => {
    dragState.isDragging = true;
    const img = dragState.slot.querySelector('img');
    const quantity = dragState.slot.querySelector('.item-quantity');
    dragState.slot.classList.add('drag-source');
    dragGhost.innerHTML = '';
    
    if (img) dragGhost.appendChild(img.cloneNode(true));
    if (quantity) dragGhost.appendChild(quantity.cloneNode(true));
    
    dragGhost.classList.add('active');
    updateGhostPosition(e);
    
    document.querySelectorAll('.slot').forEach(slot => {
      removeTooltip(slot);
      slot._tooltipEnabled = false;
    });
    
    highlightEmptySlots();
  };

  const handleDragEnd = e => {
    if (!dragState) return;
    const dropSlot = document.elementFromPoint(e.clientX, e.clientY)?.closest('.slot');
    if (dragState.slot) dragState.slot.classList.remove('drag-source');
    if (dropSlot && dropSlot !== dragState.slot && dropSlot.parentElement.dataset.container) {
      hytopia.sendData({
        type: 'moveItem',
        fromType: dragState.container,
        fromIndex: dragState.index,
        toType: dropSlot.parentElement.dataset.container,
        toIndex: Array.from(dropSlot.parentElement.children).indexOf(dropSlot)
      });
    }
    dragGhost.classList.remove('active');
    dragGhost.innerHTML = '';
    removeEmptySlotHighlighting();
  };

  const updateGhostPosition = e => {
    dragGhost.style.left = `${e.clientX + 15}px`;
    dragGhost.style.top = `${e.clientY - 15}px`;
    dragGhost.style.transform = 'translate(-50%, -50%)';
  };

  const highlightEmptySlots = () => setEmptySlotHighlighting(true);
  const removeEmptySlotHighlighting = () => setEmptySlotHighlighting(false);

  const updateDropHover = e => {
    const candidate = document.elementFromPoint(e.clientX, e.clientY)?.closest('.slot');
    const isDroppable = candidate && candidate !== dragState.slot && !candidate.querySelector('img') && candidate.parentElement?.dataset?.container;
    if (dropHoverSlot && dropHoverSlot !== candidate) {
      dropHoverSlot.classList.remove('drop-hover');
      dropHoverSlot = null;
    }
    if (isDroppable && dropHoverSlot !== candidate) {
      candidate.classList.add('drop-hover');
      dropHoverSlot = candidate;
    }
  };

  const setEmptySlotHighlighting = enable => {
    document.querySelectorAll('.slot').forEach(slot => {
      if (enable) {
        if (!slot.querySelector('img') && slot !== (dragState && dragState.slot)) {
          slot.classList.add('drop-target');
        } else {
          slot.classList.remove('drop-target');
        }
      } else {
        slot.classList.remove('drop-target', 'drop-hover');
      }
    });
    if (!enable) dropHoverSlot = null;
  };

  const createTooltip = (slot, itemData) => {
    const tooltip = document.createElement('div');
    tooltip.className = 'item-tooltip';
    const isWeapon = itemData.stats && itemData.ammoType;
    
    let tooltipHTML = `
      <div class="tooltip-header">
        <span class="tooltip-name rarity-${itemData.rarity || 'common'}">${itemData.name}</span>
      </div>
    `;
    
    if (isWeapon && itemData.stats) {
      const { description, bulletType, statsHTML } = createWeaponStatsHTML(itemData.stats, itemData.description || '');
      if (description) tooltipHTML += `<div class="tooltip-description">${description}</div>`;
      if (bulletType) tooltipHTML += `<div class="bullet-type">${bulletType}</div>`;
      tooltipHTML += statsHTML;
    } else if (itemData.description) {
      tooltipHTML += `<div class="tooltip-description">${itemData.description}</div>`;
    }
    
    if (itemData.quantity > 1) {
      tooltipHTML += `<div class="tooltip-quantity">Quantity: ${itemData.quantity}</div>`;
    }
    
    tooltip.innerHTML = tooltipHTML;
    document.body.appendChild(tooltip);
    slot._tooltip = tooltip;
    slot.addEventListener('mouseenter', handleTooltipShow);
    slot.addEventListener('mouseleave', handleTooltipHide);
  };

  const removeTooltip = slot => {
    if (slot._tooltip) {
      slot._tooltip.remove();
      slot._tooltip = null;
    }
    slot.removeEventListener('mouseenter', handleTooltipShow);
    slot.removeEventListener('mouseleave', handleTooltipHide);
  };

  const handleTooltipShow = e => {
    const slot = e.currentTarget;
    const tooltip = slot._tooltip;
    if (tooltip) {
      tooltip.style.display = 'block';
      positionTooltip(slot, tooltip);
    }
  };

  const handleTooltipHide = e => {
    const slot = e.currentTarget;
    const tooltip = slot._tooltip;
    if (tooltip) tooltip.style.display = 'none';
  };

  const createLazyTooltip = e => {
    const slot = e.currentTarget;
    if (slot._itemData && !slot._tooltip) {
      if (dragState && dragState.isDragging || slot._tooltipEnabled === false) return;
      
      createTooltip(slot, slot._itemData);
      slot.removeEventListener('mouseenter', createLazyTooltip);
      handleTooltipShow(e);
    }
  };

  const positionTooltip = (slot, tooltip) => {
    const slotRect = slot.getBoundingClientRect();
    let left = slotRect.right + 8;
    let top = slotRect.top;
    const tooltipWidth = 250;
    const tooltipHeight = 80;
    
    if (left + tooltipWidth > window.innerWidth) {
      left = slotRect.left - tooltipWidth - 8;
    }
    if (top + tooltipHeight > window.innerHeight) {
      top = window.innerHeight - tooltipHeight - 8;
    }
    
    left = Math.max(8, left);
    top = Math.max(8, top);
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
  };

  const createWeaponStatsHTML = (stats, description) => {
    const getBulletType = description => {
      const ammoMatch = description.match(/Ammo:\s*([^\n]+)/);
      return ammoMatch ? ammoMatch[1].trim() : null;
    };
    
    const getRealisticDescription = description => {
      const lines = description.split('\n');
      const descriptionLines = [];
      for (const line of lines) {
        if (line.startsWith('Ammo:') || line.startsWith('Damage:') || 
            line.startsWith('Fire Rate:') || line.startsWith('Range:') || 
            line.startsWith('Magazine:')) {
          break;
        }
        if (line.trim()) descriptionLines.push(line.trim());
      }
      return descriptionLines.join(' ');
    };
    
    const bulletType = getBulletType(description);
    const realisticDescription = getRealisticDescription(description);
    const statsHTML = `
      <div class="key-stats">
        <div class="stat-group">
          <span class="stat-label">DMG</span>
          <span class="stat-value">${stats.damage}</span>
        </div>
        <div class="stat-group">
          <span class="stat-label">RPM</span>
          <span class="stat-value">${stats.fireRate}</span>
        </div>
        <div class="stat-group">
          <span class="stat-label">MAG</span>
          <span class="stat-value">${stats.magazineSize}</span>
        </div>
      </div>
    `;
    
    return { description: realisticDescription, bulletType, statsHTML };
  };





  initializeHotbar();
  initializeInventoryGrids();

  window.addEventListener('load', () => {
    setTimeout(() => setScreenFade(false, 350), 300);
    setTimeout(() => {
      try { hytopia.sendData({ type: 'requestHudSync' }); } catch {}
      try { hytopia.sendData({ type: 'requestWeaponHud' }); } catch {}
    }, 80);
  });

  const setScreenFade = (show, durationMs) => {
    const fader = document.getElementById('screen-fader');
    if (!fader) return;
    if (typeof durationMs === 'number') {
      fader.style.transition = `opacity ${Math.max(80, Math.min(1000, durationMs))}ms ease-in-out`;
    } else {
      fader.style.transition = `opacity 250ms ease-in-out`;
    }
    fader.classList.toggle('hidden', !show);
  };

  const updateCompass = data => {
    const el = document.getElementById('compass-indicator');
    if (!el) return;
    const letter = (data && data.letter) ? String(data.letter).toUpperCase().charAt(0) : 'N';
    el.textContent = letter;
  };

  // Kill Feed System
  const killFeedContainer = document.querySelector('.kill-feed-container');
  const killFeedEntries = [];
  const MAX_KILL_FEED_ENTRIES = 5;
  const KILL_FEED_DURATION = 4000; // 4 seconds

  const addKillFeedEntry = (killerName, weaponIconUri, victimName) => {
    if (!killFeedContainer) {
      return;
    }

    const entry = document.createElement('div');
    entry.className = 'kill-feed-entry';
    
    entry.innerHTML = `
      <span class="kill-feed-killer">${killerName}</span>
      <img class="kill-feed-weapon" src="${CDN_ASSETS_URL}/${weaponIconUri}" alt="weapon">
      <span class="kill-feed-victim">${victimName}</span>
    `;

    killFeedContainer.appendChild(entry);
    killFeedEntries.push(entry);

    // Remove oldest entry if we exceed max
    if (killFeedEntries.length > MAX_KILL_FEED_ENTRIES) {
      const oldestEntry = killFeedEntries.shift();
      if (oldestEntry && oldestEntry.parentNode) {
        oldestEntry.classList.add('fade-out');
        setTimeout(() => {
          if (oldestEntry.parentNode) {
            oldestEntry.parentNode.removeChild(oldestEntry);
          }
        }, 1800);
      }
    }

    // Remove this entry after duration
    setTimeout(() => {
      if (entry.parentNode) {
        entry.classList.add('fade-out');
        setTimeout(() => {
          if (entry.parentNode) {
            entry.parentNode.removeChild(entry);
          }
          const index = killFeedEntries.indexOf(entry);
          if (index > -1) {
            killFeedEntries.splice(index, 1);
          }
        }, 1800);
      }
    }, KILL_FEED_DURATION);
  };

</script>


</body>
</html>