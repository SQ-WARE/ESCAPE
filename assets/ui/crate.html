<link rel="stylesheet" href="{{CDN_ASSETS_URL}}/ui/css/app.css">
<link rel="stylesheet" href="{{CDN_ASSETS_URL}}/ui/css/stash.css">

<div class="stash-overlay" style="display:flex; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); background: rgba(0,0,0,0.25);">
  <div class="stash-interface">
    <div class="stash-header-panel">
      <div class="stash-title-section">
        <h2 class="stash-title">LOOT CRATE</h2>
        <div class="stash-subtitle">INVENTORY MANAGEMENT</div>
      </div>
      <div class="stash-controls">
        <button class="close-btn-stash" id="crate-close">CLOSE</button>
      </div>
    </div>
    <div class="stash-content-panel">
      <div class="inventory-side">
        <div class="inventory-section">
          <h3 class="section-title">BACKPACK</h3>
          <div class="backpack-grid" id="inv-grid" data-container="backpack"></div>
        </div>
        <div class="inventory-section">
          <h3 class="section-title">HOTBAR</h3>
          <div class="hotbar-grid" id="hotbar-grid" data-container="hotbar"></div>
        </div>
      </div>
      <div class="stash-side">
        <div class="inventory-section">
          <h3 class="section-title">CRATE CONTENTS</h3>
          <div class="stash-grid" id="crate-grid" data-container="crate"></div>
        </div>
      </div>
    </div>
    <div class="drag-ghost"></div>
  </div>
</div>

<template id="crate-slot">
  <div class="stash-slot"></div>
</template>

<script>
  const CDN_ASSETS_URL = '{{CDN_ASSETS_URL}}';
  const grid = document.getElementById('crate-grid');
  const invGrid = document.getElementById('inv-grid');
  const hotbarGrid = document.getElementById('hotbar-grid');
  const closeBtn = document.getElementById('crate-close');
  const tpl = document.getElementById('crate-slot');
  let currentCrateId = null;
  let crateDragState = null;
  let dropHoverSlot = null;
  const dragGhost = document.querySelector('.drag-ghost');

  // Removed extra auto-sync; server sends initial contents

  closeBtn.addEventListener('click', () => {
    hytopia.sendData({ type: 'crate-close', crateId: currentCrateId });
    hytopia.sendData({ type: 'requestHudSync' });
  });

  // ESC to close
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      e.preventDefault();
      hytopia.sendData({ type: 'crate-close', crateId: currentCrateId });
      hytopia.sendData({ type: 'requestHudSync' });
      // Ask server to re-broadcast current weapon HUD to avoid "No Weapon" state
      hytopia.sendData({ type: 'requestWeaponHud' });
    }
  });

  function setupGrid(container, size, width, slotClass) {
    container.innerHTML = '';
    for (let i = 0; i < size; i++) {
      const node = tpl.content.cloneNode(true);
      const slot = node.querySelector('.stash-slot');
      slot.className = slotClass;
      slot.setAttribute('data-position', i.toString());
      container.appendChild(node);
    }
    container.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
  }

  function updateSlot(container, position, itemData) {
    const slot = container.children[position];
    if (!slot) return;
    
    // Clear any existing content and data
    slot.innerHTML = '';
    slot._itemData = null;
    slot._tooltipEnabled = false;
    if (slot._tooltip) { 
      slot._tooltip.remove(); 
      slot._tooltip = null; 
    }
    
    // Handle empty slots or removed items
    if (!itemData || itemData.removed || !itemData.name || itemData.name === 'No Weapon') {
      return;
    }
    
    // Handle invalid or missing icon
    const iconUri = itemData.iconImageUri;
    if (!iconUri || iconUri === 'icons/chest.png' || iconUri.includes('invalid')) {
      return;
    }
    
    // Determine if item is ammo
    const isAmmo = itemData.name && (
      itemData.name.includes('9×19mm') || 
      itemData.name.includes('7.62×39mm') || 
      itemData.name.includes('12.7×108mm') || 
      itemData.name.includes('12 Gauge') ||
      itemData.name.toLowerCase().includes('ammo') ||
      itemData.name.toLowerCase().includes('bullet')
    );
    
    // Only show quantity for items with quantity > 1
    let quantityDisplay = '';
    if (itemData.quantity && itemData.quantity > 1) {
      quantityDisplay = `<span class="${isAmmo ? 'ammo-label' : 'item-quantity'}">${itemData.quantity}</span>`;
    }
    
    // Create the slot content
    slot.innerHTML = `<img src="${CDN_ASSETS_URL}/${iconUri}" alt="${itemData.name || ''}">${quantityDisplay}`;
    slot._itemData = itemData;
    slot._tooltipEnabled = true;

    // Wire tooltip like stash/inventory
    slot.removeEventListener('mouseenter', createCrateTooltip);
    slot.removeEventListener('mouseleave', removeCrateTooltip);
    slot.removeEventListener('mousemove', updateCrateTooltipPosition);
    slot.addEventListener('mouseenter', createCrateTooltip);
    slot.addEventListener('mouseleave', removeCrateTooltip);
    slot.addEventListener('mousemove', updateCrateTooltipPosition);

    slot.onmousedown = (e) => {
      if (e.shiftKey && e.button === 0) {
        e.preventDefault();
        const from = slot.classList.contains('backpack-slot') ? 'backpack' : slot.classList.contains('hotbar-slot') ? 'hotbar' : 'crate';
        const fromIndex = parseInt(slot.getAttribute('data-position'));
        hytopia.sendData({ type: 'crate-quickMove', crateId: currentCrateId, fromType: from, fromIndex });
        return;
      }
      if (e.button !== 0 || !slot.querySelector('img')) return;
      e.preventDefault();
      const from = slot.classList.contains('backpack-slot') ? 'backpack' : slot.classList.contains('hotbar-slot') ? 'hotbar' : 'crate';
      crateDragState = { slot, from, fromIndex: parseInt(slot.getAttribute('data-position')), startX: e.clientX, startY: e.clientY, isDragging: false };
      document.addEventListener('mousemove', handleDragMove, { capture: true });
      document.addEventListener('mouseup', handleDragUp);
    };
  }

  // Tooltip helpers - using stash tooltip styles
  function createWeaponStatsHTML(stats, description, ammoType) {
    const ammoMap = { pistol: '9×19mm Parabellum', rifle: '7.62×39mm', sniper: '12.7×108mm', shotgun: '12 Gauge' };
    const bulletType = ammoMap[ammoType] || ammoType || '';
    const statsHTML = `
      <div class="weapon-stats">
        <div class="key-stats">
          <div class="stat-group"><span class="stat-label">DMG</span><span class="stat-value">${stats.damage}</span></div>
          <div class="stat-group"><span class="stat-label">RPM</span><span class="stat-value">${stats.fireRate}</span></div>
          <div class="stat-group"><span class="stat-label">MAG</span><span class="stat-value">${stats.magazineSize}</span></div>
        </div>
      </div>`;
    return { bulletType, statsHTML, description };
  }

  function createCrateTooltip(e) {
    const slot = e.currentTarget;
    const itemData = slot._itemData;
    if (!itemData || slot._tooltipEnabled === false) return;
    removeCrateTooltip(e);
    const tooltip = document.createElement('div');
    tooltip.className = 'item-tooltip';
    const isWeapon = itemData.stats && itemData.ammoType;
    let tooltipHTML = `<div class="tooltip-header"><span class="tooltip-name rarity-${itemData.rarity || 'common'}">${itemData.name || ''}</span></div>`;
    if (isWeapon) {
      const { bulletType, statsHTML, description } = createWeaponStatsHTML(itemData.stats, itemData.description || '', itemData.ammoType || 'pistol');
      if (itemData.description) tooltipHTML += `<div class="tooltip-description">${itemData.description}</div>`;
      if (bulletType) tooltipHTML += `<div class="bullet-type">${bulletType}</div>`;
      tooltipHTML += statsHTML;
    } else if (itemData.description) {
      tooltipHTML += `<div class="tooltip-description">${itemData.description}</div>`;
    }
    if (itemData.quantity && itemData.quantity > 1) {
      tooltipHTML += `<div class="tooltip-quantity">Quantity: ${itemData.quantity}</div>`;
    }
    tooltip.innerHTML = tooltipHTML;
    document.body.appendChild(tooltip);
    slot._tooltip = tooltip;
    positionCrateTooltip(e, tooltip);
  }

  function removeCrateTooltip(e) {
    const slot = e.currentTarget;
    if (slot && slot._tooltip) {
      slot._tooltip.remove();
      slot._tooltip = null;
    }
  }

  function updateCrateTooltipPosition(e) {
    const slot = e.currentTarget;
    const tooltip = slot._tooltip;
    if (tooltip) positionCrateTooltip(e, tooltip);
  }

  function positionCrateTooltip(e, tooltip) {
    let left = e.clientX + 15;
    let top = e.clientY - 10;
    tooltip.style.display = 'block';
    const rect = tooltip.getBoundingClientRect();
    if (left + rect.width > window.innerWidth) left = e.clientX - rect.width - 15;
    if (top + rect.height > window.innerHeight) top = e.clientY - rect.height - 10;
    if (top < 10) top = 10;
    tooltip.style.left = left + 'px';
    tooltip.style.top = top + 'px';
  }

  function handleDragMove(e) {
    if (!crateDragState) return;
    const dx = e.clientX - crateDragState.startX;
    const dy = e.clientY - crateDragState.startY;
    if (!crateDragState.isDragging && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
      crateDragState.isDragging = true;
      startDragGhost(crateDragState.slot);
      setEmptySlotHighlighting(true);
    }
    if (crateDragState.isDragging) {
      dragGhost.style.left = `${e.clientX + 15}px`;
      dragGhost.style.top = `${e.clientY - 15}px`;
      dragGhost.style.transform = 'translate(-50%, -50%)';
      updateDropHover(e);
    }
  }

  function handleDragUp(e) {
    if (crateDragState && crateDragState.isDragging) {
      const dropSlot = document.elementFromPoint(e.clientX, e.clientY)?.closest('.stash-slot, .hotbar-slot, .backpack-slot');
      if (dropSlot && dropSlot !== crateDragState.slot) {
        let to = dropSlot.classList.contains('backpack-slot') ? 'backpack' : dropSlot.classList.contains('hotbar-slot') ? 'hotbar' : 'crate';
        const toIndex = parseInt(dropSlot.getAttribute('data-position')) || Array.from(dropSlot.parentElement.children).indexOf(dropSlot);
        hytopia.sendData({ type: 'crate-move', crateId: currentCrateId, fromType: crateDragState.from, fromIndex: crateDragState.fromIndex, toType: to, toIndex });
      }
    }
    finalizeDragVisuals();
    setEmptySlotHighlighting(false);
    document.removeEventListener('mousemove', handleDragMove);
    document.removeEventListener('mouseup', handleDragUp);
    crateDragState = null;
  }

  function startDragGhost(slot) {
    dragGhost.innerHTML = '';
    const img = slot.querySelector('img');
    if (img) dragGhost.appendChild(img.cloneNode(true));
    dragGhost.classList.add('active');
  }

  function stopDragGhost() {
    dragGhost.classList.remove('active');
    dragGhost.innerHTML = '';
  }

  function setEmptySlotHighlighting(enable) {
    document.querySelectorAll('.stash-slot, .backpack-slot, .hotbar-slot').forEach(slot => {
      if (enable) {
        if (!slot.querySelector('img')) slot.classList.add('drop-target');
        else slot.classList.remove('drop-target');
      } else {
        slot.classList.remove('drop-target', 'drop-hover');
      }
    });
  }

  function updateDropHover(e) {
    const candidate = document.elementFromPoint(e.clientX, e.clientY)?.closest('.stash-slot, .hotbar-slot, .backpack-slot');
    const isEmpty = candidate && !candidate.querySelector('img');
    if (dropHoverSlot && dropHoverSlot !== candidate) {
      dropHoverSlot.classList.remove('drop-hover');
      dropHoverSlot = null;
    }
    if (isEmpty) {
      candidate.classList.add('drop-hover');
      dropHoverSlot = candidate;
    }
  }

  function finalizeDragVisuals() {
    document.querySelectorAll('.stash-slot, .backpack-slot, .hotbar-slot').forEach(slot => slot.classList.remove('drop-target', 'drop-hover'));
    stopDragGhost();
  }

  // number keys assignment like stash
  document.addEventListener('keydown', (e) => {
    const key = parseInt(e.key);
    if (!isNaN(key) && key >= 1 && key <= 9) {
      const hovered = document.querySelector('.stash-slot:hover, .backpack-slot:hover, .hotbar-slot:hover');
      if (!hovered) return;
      const numberIndex = key - 1;
      const hoveredIndex = parseInt(hovered.getAttribute('data-position')) || Array.from(hovered.parentElement.children).indexOf(hovered);
      const isBackpackSlot = hovered.classList.contains('backpack-slot');
      const isHotbarSlot = hovered.classList.contains('hotbar-slot');
      const isCrateSlot = hovered.classList.contains('stash-slot');
      if (hovered.querySelector('img')) {
        const fromType = isBackpackSlot ? 'backpack' : isHotbarSlot ? 'hotbar' : 'crate';
        hytopia.sendData({ type: 'crate-move', crateId: currentCrateId, fromType, fromIndex: hoveredIndex, toType: 'hotbar', toIndex: numberIndex });
        finalizeDragVisuals();
      } else if (isBackpackSlot) {
        hytopia.sendData({ type: 'crate-move', crateId: currentCrateId, fromType: 'hotbar', fromIndex: numberIndex, toType: 'backpack', toIndex: hoveredIndex });
        finalizeDragVisuals();
      } else if (isCrateSlot) {
        hytopia.sendData({ type: 'crate-move', crateId: currentCrateId, fromType: 'hotbar', fromIndex: numberIndex, toType: 'crate', toIndex: hoveredIndex });
        finalizeDragVisuals();
      }
    }
  });

  function renderAll(crates, inv, hotbar) {
    // clear all slots first
    for (let i = 0; i < grid.children.length; i++) updateSlot(grid, i, { removed: true });
    for (let i = 0; i < invGrid.children.length; i++) updateSlot(invGrid, i, { removed: true });
    for (let i = 0; i < hotbarGrid.children.length; i++) updateSlot(hotbarGrid, i, { removed: true });
    // apply payloads
    (crates || []).forEach(it => updateSlot(grid, it.position, it));
    (inv || []).forEach(it => updateSlot(invGrid, it.position, it));
    (hotbar || []).forEach(it => updateSlot(hotbarGrid, it.position, it));
  }

  hytopia.onData(data => {
    if (data.type === 'crate-contents') {
      currentCrateId = data.crateId;
      const width = data.gridWidth || 9;
      const size = data.size || 72;
      setupGrid(grid, size, width, 'stash-slot');
      setupGrid(invGrid, 27, 9, 'backpack-slot');
      setupGrid(hotbarGrid, 9, 9, 'hotbar-slot');
      renderAll(data.items || data.crate || [], data.inventory || [], data.hotbar || []);
      hytopia.lockPointer(false, true);
      // No additional sync; rely on server updates on interaction
      // Server will push crate-sync after moves; initial payload already has inventories
    }
    if (data.type === 'crate-sync') {
      renderAll(data.crate || [], data.inventory || [], data.hotbar || []);
    }
  });
</script>